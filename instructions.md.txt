# ğŸ® PAC-MAN GAME - COMPLETE BUILD INSTRUCTIONS FOR CLAUDE CODE

## ğŸ¯ PROJECT OBJECTIVE
Build a complete, modern recreation of the classic Pac-Man game using Python, Pygame, and Pygbag for web deployment. The game should be developed in progressive stages, with each stage fully tested before moving to the next.

---

## ğŸ“‹ TABLE OF CONTENTS
1. [Development Philosophy](#development-philosophy)
2. [Technical Stack](#technical-stack)
3. [Project Structure](#project-structure)
4. [Stage-by-Stage Development](#stage-by-stage-development)
5. [Core Game Mechanics](#core-game-mechanics)
6. [Visual Design Guidelines](#visual-design-guidelines)
7. [AI & Ghost Behavior](#ai--ghost-behavior)
8. [Testing & Validation](#testing--validation)
9. [Git Workflow](#git-workflow)
10. [Deployment Instructions](#deployment-instructions)

---

## ğŸ§  DEVELOPMENT PHILOSOPHY

### Core Principles
- **Incremental Development**: Build in stages, test each stage before proceeding
- **Autonomous Operation**: Full directory-level permissions granted - no manual approvals needed
- **Quality First**: Each feature must be fully functional before moving forward
- **Git-Tracked**: All development tracked through version control
- **Modular Design**: Separate concerns for easy maintenance and extension

### Stage Completion Criteria
Each stage must meet these criteria before proceeding:
1. âœ… All features implemented and functional
2. âœ… No critical bugs or crashes
3. âœ… Code committed to Git with descriptive messages
4. âœ… Basic play-testing completed
5. âœ… Performance validated (60 FPS minimum)

---

## ğŸ› ï¸ TECHNICAL STACK

### Primary Technologies
```yaml
Language: Python 3.10+
Game Engine: Pygame 2.5+
Web Deployment: Pygbag
Version Control: Git
```

### Required Libraries
```python
# Core Dependencies
pygame>=2.5.0
pygbag>=0.8.0

# Optional (for enhanced features)
numpy>=1.24.0  # For advanced math/AI
```

### Installation Commands
```bash
pip install pygame pygbag --break-system-packages
pip install numpy --break-system-packages  # Optional
```

---

## ğŸ“ PROJECT STRUCTURE

Create the following directory structure:

```
pacman-game/
â”œâ”€â”€ .git/                          # Git repository
â”œâ”€â”€ .gitignore                     # Git ignore file
â”œâ”€â”€ README.md                      # Project documentation
â”œâ”€â”€ requirements.txt               # Python dependencies
â”œâ”€â”€ main.py                        # Entry point
â”‚
â”œâ”€â”€ src/                           # Source code
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ game.py                    # Main game loop
â”‚   â”œâ”€â”€ config.py                  # Game configuration
â”‚   â”œâ”€â”€ constants.py               # Game constants
â”‚   â”‚
â”‚   â”œâ”€â”€ entities/                  # Game entities
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ player.py              # Pac-Man class
â”‚   â”‚   â”œâ”€â”€ ghost.py               # Ghost base class
â”‚   â”‚   â”œâ”€â”€ ghost_ai.py            # AI behaviors
â”‚   â”‚   â””â”€â”€ powerup.py             # Power-up items
â”‚   â”‚
â”‚   â”œâ”€â”€ levels/                    # Level management
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ level_manager.py      # Level progression
â”‚   â”‚   â”œâ”€â”€ maze.py                # Maze structure
â”‚   â”‚   â””â”€â”€ level_configs.py      # Level definitions
â”‚   â”‚
â”‚   â”œâ”€â”€ ui/                        # User interface
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ hud.py                 # Heads-up display
â”‚   â”‚   â”œâ”€â”€ menus.py               # Menu screens
â”‚   â”‚   â””â”€â”€ particles.py           # Particle effects
â”‚   â”‚
â”‚   â””â”€â”€ utils/                     # Utility functions
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ collision.py           # Collision detection
â”‚       â”œâ”€â”€ pathfinding.py         # A* pathfinding
â”‚       â””â”€â”€ helpers.py             # Helper functions
â”‚
â”œâ”€â”€ assets/                        # Game assets
â”‚   â”œâ”€â”€ fonts/                     # Font files
â”‚   â”œâ”€â”€ sounds/                    # Sound effects (optional)
â”‚   â””â”€â”€ images/                    # Sprite images (optional)
â”‚
â””â”€â”€ tests/                         # Test files
    â”œâ”€â”€ __init__.py
    â””â”€â”€ test_basic.py              # Basic tests
```

---

## ğŸ—ï¸ STAGE-BY-STAGE DEVELOPMENT

## **STAGE 1: FOUNDATION & CORE MECHANICS** ğŸ¯

### Objectives
- Set up project structure
- Initialize Git repository
- Create basic game window
- Implement Pac-Man movement
- Build basic maze structure
- Add pellet collection

### Deliverables

#### 1.1 Project Initialization
```python
# .gitignore content
__pycache__/
*.pyc
*.pyo
*.pyd
.Python
build/
dist/
*.egg-info/
.vscode/
.idea/
*.swp
*.swo
*~
.DS_Store
```

#### 1.2 Configuration Setup (src/config.py)
```python
"""Game configuration and settings"""

# Screen settings
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 900
FPS = 60

# Colors (Retro-Futuristic palette)
BLACK = (10, 10, 15)
NEON_BLUE = (0, 240, 255)
NEON_PINK = (255, 20, 147)
NEON_GREEN = (57, 255, 20)
NEON_YELLOW = (255, 255, 0)
NEON_ORANGE = (255, 140, 0)
NEON_PURPLE = (191, 64, 191)
WHITE = (255, 255, 255)
GRAY = (128, 128, 128)

# Maze settings
TILE_SIZE = 25
MAZE_WIDTH = 28  # Classic Pac-Man dimensions
MAZE_HEIGHT = 31

# Player settings
PLAYER_SPEED = 2.5
PLAYER_RADIUS = 10

# Ghost settings
GHOST_SPEED = 2.0
GHOST_FRIGHTENED_SPEED = 1.5
GHOST_RADIUS = 10

# Game mechanics
POWER_PELLET_DURATION = 8000  # milliseconds
INVINCIBILITY_FLASH_SPEED = 100  # milliseconds
LEVEL_CLEAR_DELAY = 2000  # milliseconds
```

#### 1.3 Main Game Class (src/game.py)
```python
"""Main game class and loop"""
import pygame
import sys
from src.config import *

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("PAC-MAN - Retro Futuristic Edition")
        self.clock = pygame.time.Clock()
        self.running = True
        self.dt = 0
        
    def run(self):
        """Main game loop"""
        while self.running:
            self.handle_events()
            self.update()
            self.render()
            self.dt = self.clock.tick(FPS) / 1000.0
            
    def handle_events(self):
        """Handle input events"""
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
                
    def update(self):
        """Update game state"""
        pass
        
    def render(self):
        """Render game"""
        self.screen.fill(BLACK)
        pygame.display.flip()
        
    def quit(self):
        """Clean up and quit"""
        pygame.quit()
        sys.exit()
```

#### 1.4 Maze Structure (src/levels/maze.py)
```python
"""Maze generation and management"""
from src.config import *

# Classic Pac-Man maze layout (0=wall, 1=pellet, 2=power pellet, 3=empty, 4=ghost house)
CLASSIC_MAZE_LAYOUT = [
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0],
    [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0],
    [0,2,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,2,0],
    [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0],
    [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
    [0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0],
    [0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0],
    [0,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,0],
    [0,0,0,0,0,0,1,0,0,0,0,0,3,0,0,3,0,0,0,0,0,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,0,0,0,0,0,3,0,0,3,0,0,0,0,0,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,0,0,3,3,3,3,3,3,3,3,3,3,0,0,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,0,0,3,0,0,0,4,4,0,0,0,3,0,0,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,0,0,3,0,4,4,4,4,4,4,0,3,0,0,1,0,0,0,0,0,0],
    [3,3,3,3,3,3,1,3,3,3,0,4,4,4,4,4,4,0,3,3,3,1,3,3,3,3,3,3],
    [0,0,0,0,0,0,1,0,0,3,0,4,4,4,4,4,4,0,3,0,0,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,0,0,3,0,0,0,0,0,0,0,0,3,0,0,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,0,0,3,3,3,3,3,3,3,3,3,3,0,0,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,0,0,3,0,0,0,0,0,0,0,0,3,0,0,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,0,0,3,0,0,0,0,0,0,0,0,3,0,0,1,0,0,0,0,0,0],
    [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0],
    [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0],
    [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0],
    [0,2,1,1,0,0,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,0,0,1,1,2,0],
    [0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0],
    [0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0],
    [0,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,0],
    [0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0],
    [0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0],
    [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
]

class Maze:
    def __init__(self):
        self.layout = [row[:] for row in CLASSIC_MAZE_LAYOUT]
        self.pellet_count = self.count_pellets()
        
    def count_pellets(self):
        """Count total pellets in maze"""
        count = 0
        for row in self.layout:
            count += row.count(1) + row.count(2)
        return count
        
    def get_tile(self, x, y):
        """Get tile type at grid position"""
        if 0 <= y < len(self.layout) and 0 <= x < len(self.layout[0]):
            return self.layout[y][x]
        return 0  # Wall by default
        
    def is_walkable(self, x, y):
        """Check if position is walkable"""
        tile = self.get_tile(x, y)
        return tile != 0  # Everything except walls
        
    def eat_pellet(self, x, y):
        """Eat pellet at position"""
        if 0 <= y < len(self.layout) and 0 <= x < len(self.layout[0]):
            tile = self.layout[y][x]
            if tile in [1, 2]:  # Regular or power pellet
                self.layout[y][x] = 3  # Empty
                return tile
        return None
        
    def render(self, screen, offset_x=0, offset_y=0):
        """Render the maze"""
        for y, row in enumerate(self.layout):
            for x, tile in enumerate(row):
                px = offset_x + x * TILE_SIZE
                py = offset_y + y * TILE_SIZE
                
                if tile == 0:  # Wall
                    pygame.draw.rect(screen, NEON_BLUE, 
                                   (px, py, TILE_SIZE, TILE_SIZE), 2)
                elif tile == 1:  # Pellet
                    pygame.draw.circle(screen, WHITE,
                                     (px + TILE_SIZE//2, py + TILE_SIZE//2), 2)
                elif tile == 2:  # Power pellet
                    pygame.draw.circle(screen, NEON_YELLOW,
                                     (px + TILE_SIZE//2, py + TILE_SIZE//2), 5)
```

#### 1.5 Player Entity (src/entities/player.py)
```python
"""Pac-Man player entity"""
import pygame
from src.config import *

class Player:
    def __init__(self, x, y, maze):
        self.x = x
        self.y = y
        self.maze = maze
        self.speed = PLAYER_SPEED
        self.direction = (0, 0)
        self.next_direction = (0, 0)
        self.radius = PLAYER_RADIUS
        self.score = 0
        self.lives = 3
        self.powered_up = False
        self.power_timer = 0
        
    def handle_input(self):
        """Handle keyboard input"""
        keys = pygame.key.get_pressed()
        
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.next_direction = (-1, 0)
        elif keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.next_direction = (1, 0)
        elif keys[pygame.K_UP] or keys[pygame.K_w]:
            self.next_direction = (0, -1)
        elif keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.next_direction = (0, 1)
            
    def update(self, dt):
        """Update player position"""
        # Try to change direction
        if self.can_move(self.next_direction):
            self.direction = self.next_direction
            
        # Move in current direction
        if self.can_move(self.direction):
            self.x += self.direction[0] * self.speed
            self.y += self.direction[1] * self.speed
            
        # Wrap around edges
        self.x = self.x % (MAZE_WIDTH * TILE_SIZE)
        
        # Check for pellet collection
        self.check_pellet_collision()
        
        # Update power-up timer
        if self.powered_up:
            self.power_timer -= dt * 1000
            if self.power_timer <= 0:
                self.powered_up = False
                
    def can_move(self, direction):
        """Check if movement in direction is valid"""
        if direction == (0, 0):
            return False
            
        # Calculate next position
        next_x = self.x + direction[0] * (self.radius + 2)
        next_y = self.y + direction[1] * (self.radius + 2)
        
        # Convert to grid coordinates
        grid_x = int(next_x / TILE_SIZE)
        grid_y = int(next_y / TILE_SIZE)
        
        return self.maze.is_walkable(grid_x, grid_y)
        
    def check_pellet_collision(self):
        """Check and handle pellet collisions"""
        grid_x = int(self.x / TILE_SIZE)
        grid_y = int(self.y / TILE_SIZE)
        
        pellet = self.maze.eat_pellet(grid_x, grid_y)
        
        if pellet == 1:  # Regular pellet
            self.score += 10
        elif pellet == 2:  # Power pellet
            self.score += 50
            self.powered_up = True
            self.power_timer = POWER_PELLET_DURATION
            
    def render(self, screen, offset_x=0, offset_y=0):
        """Render the player"""
        px = offset_x + int(self.x)
        py = offset_y + int(self.y)
        
        # Draw Pac-Man as a circle
        color = NEON_YELLOW if not self.powered_up else NEON_GREEN
        pygame.draw.circle(screen, color, (px, py), self.radius)
        
        # Draw mouth (simple animation)
        if self.direction != (0, 0):
            mouth_angle = 30  # degrees
            start_angle = 0
            
            if self.direction == (1, 0):  # Right
                start_angle = mouth_angle
            elif self.direction == (-1, 0):  # Left
                start_angle = 180 + mouth_angle
            elif self.direction == (0, -1):  # Up
                start_angle = 270 + mouth_angle
            elif self.direction == (0, 1):  # Down
                start_angle = 90 + mouth_angle
```

#### 1.6 Entry Point (main.py)
```python
"""Main entry point for the game"""
from src.game import Game

def main():
    game = Game()
    try:
        game.run()
    finally:
        game.quit()

if __name__ == "__main__":
    main()
```

### Stage 1 Testing Checklist
- [ ] Game window opens correctly (800x900)
- [ ] Maze renders with walls and pellets
- [ ] Pac-Man spawns in correct position
- [ ] Arrow keys/WASD control movement
- [ ] Pac-Man cannot move through walls
- [ ] Pellets disappear when collected
- [ ] Score increases when collecting pellets
- [ ] Power pellets trigger power-up state
- [ ] Game runs at 60 FPS
- [ ] Code committed to Git

### Git Commands for Stage 1
```bash
git init
git add .
git commit -m "Stage 1: Foundation complete - basic gameplay working"
```

---

## **STAGE 2: GHOST AI & COLLISION** ğŸ‘»

### Objectives
- Implement 4 ghosts with unique AI behaviors
- Add collision detection between player and ghosts
- Implement frightened mode when powered up
- Add respawn mechanics
- Implement basic pathfinding (A*)

### Deliverables

#### 2.1 Ghost Base Class (src/entities/ghost.py)
```python
"""Base ghost class"""
import pygame
import random
from src.config import *

class Ghost:
    def __init__(self, x, y, color, name, maze):
        self.x = x
        self.y = y
        self.start_x = x
        self.start_y = y
        self.color = color
        self.name = name
        self.maze = maze
        self.speed = GHOST_SPEED
        self.direction = (0, 0)
        self.state = "scatter"  # scatter, chase, frightened, eaten
        self.frightened_timer = 0
        self.radius = GHOST_RADIUS
        self.target = (0, 0)
        
    def update(self, dt, player):
        """Update ghost behavior"""
        # Update frightened timer
        if self.state == "frightened":
            self.frightened_timer -= dt * 1000
            if self.frightened_timer <= 0:
                self.state = "scatter"
                
        # Update AI behavior
        self.update_ai(player)
        
        # Move ghost
        self.move()
        
    def update_ai(self, player):
        """Override in subclasses for unique behaviors"""
        pass
        
    def move(self):
        """Move ghost towards target"""
        if self.can_move(self.direction):
            self.x += self.direction[0] * self.speed
            self.y += self.direction[1] * self.speed
        else:
            self.choose_direction()
            
    def can_move(self, direction):
        """Check if movement is valid"""
        if direction == (0, 0):
            return False
            
        next_x = self.x + direction[0] * (self.radius + 2)
        next_y = self.y + direction[1] * (self.radius + 2)
        
        grid_x = int(next_x / TILE_SIZE)
        grid_y = int(next_y / TILE_SIZE)
        
        return self.maze.is_walkable(grid_x, grid_y)
        
    def choose_direction(self):
        """Choose next direction"""
        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]
        valid_dirs = [d for d in directions if self.can_move(d) and d != self.reverse_direction()]
        
        if valid_dirs:
            if self.state == "frightened":
                self.direction = random.choice(valid_dirs)
            else:
                # Choose direction closest to target
                best_dir = valid_dirs[0]
                best_dist = float('inf')
                
                for d in valid_dirs:
                    next_x = self.x + d[0] * TILE_SIZE
                    next_y = self.y + d[1] * TILE_SIZE
                    dist = ((next_x - self.target[0])**2 + (next_y - self.target[1])**2)**0.5
                    
                    if dist < best_dist:
                        best_dist = dist
                        best_dir = d
                        
                self.direction = best_dir
                
    def reverse_direction(self):
        """Get reverse of current direction"""
        return (-self.direction[0], -self.direction[1])
        
    def set_frightened(self, duration):
        """Set ghost to frightened mode"""
        self.state = "frightened"
        self.frightened_timer = duration
        self.speed = GHOST_FRIGHTENED_SPEED
        self.direction = self.reverse_direction()
        
    def reset_position(self):
        """Reset ghost to starting position"""
        self.x = self.start_x
        self.y = self.start_y
        self.direction = (0, 0)
        self.state = "scatter"
        self.speed = GHOST_SPEED
        
    def render(self, screen, offset_x=0, offset_y=0):
        """Render the ghost"""
        px = offset_x + int(self.x)
        py = offset_y + int(self.y)
        
        # Change color based on state
        color = self.color
        if self.state == "frightened":
            # Flash between blue and white
            flash = int(self.frightened_timer / 200) % 2
            color = NEON_BLUE if flash else WHITE
        elif self.state == "eaten":
            color = GRAY
            
        # Draw ghost body
        pygame.draw.circle(screen, color, (px, py), self.radius)
        
        # Draw eyes (unless eaten)
        if self.state != "eaten":
            eye_offset = 3
            pygame.draw.circle(screen, WHITE, (px - eye_offset, py - 2), 2)
            pygame.draw.circle(screen, WHITE, (px + eye_offset, py - 2), 2)
```

#### 2.2 Ghost AI Behaviors (src/entities/ghost_ai.py)
```python
"""Specific ghost AI implementations"""
from src.entities.ghost import Ghost
from src.config import *

class Blinky(Ghost):
    """Red ghost - Aggressive chaser"""
    def __init__(self, x, y, maze):
        super().__init__(x, y, NEON_PINK, "Blinky", maze)
        
    def update_ai(self, player):
        """Chase player directly"""
        if self.state == "chase":
            self.target = (player.x, player.y)
        elif self.state == "scatter":
            self.target = (MAZE_WIDTH * TILE_SIZE, 0)  # Top right corner

class Pinky(Ghost):
    """Pink ghost - Ambusher"""
    def __init__(self, x, y, maze):
        super().__init__(x, y, NEON_PINK, "Pinky", maze)
        
    def update_ai(self, player):
        """Target ahead of player"""
        if self.state == "chase":
            # Target 4 tiles ahead of player
            ahead_x = player.x + player.direction[0] * TILE_SIZE * 4
            ahead_y = player.y + player.direction[1] * TILE_SIZE * 4
            self.target = (ahead_x, ahead_y)
        elif self.state == "scatter":
            self.target = (0, 0)  # Top left corner

class Inky(Ghost):
    """Cyan ghost - Strategic"""
    def __init__(self, x, y, maze):
        super().__init__(x, y, NEON_BLUE, "Inky", maze)
        
    def update_ai(self, player):
        """Complex targeting based on Blinky's position"""
        if self.state == "chase":
            # Target 2 tiles ahead of player
            ahead_x = player.x + player.direction[0] * TILE_SIZE * 2
            ahead_y = player.y + player.direction[1] * TILE_SIZE * 2
            self.target = (ahead_x, ahead_y)
        elif self.state == "scatter":
            self.target = (MAZE_WIDTH * TILE_SIZE, MAZE_HEIGHT * TILE_SIZE)

class Clyde(Ghost):
    """Orange ghost - Random/Shy"""
    def __init__(self, x, y, maze):
        super().__init__(x, y, NEON_ORANGE, "Clyde", maze)
        
    def update_ai(self, player):
        """Chase when far, scatter when close"""
        if self.state == "chase":
            dist = ((self.x - player.x)**2 + (self.y - player.y)**2)**0.5
            
            if dist > TILE_SIZE * 8:
                # Chase player when far away
                self.target = (player.x, player.y)
            else:
                # Scatter when close
                self.target = (0, MAZE_HEIGHT * TILE_SIZE)
        elif self.state == "scatter":
            self.target = (0, MAZE_HEIGHT * TILE_SIZE)  # Bottom left
```

#### 2.3 Collision Detection (src/utils/collision.py)
```python
"""Collision detection utilities"""
import math

def circle_collision(x1, y1, r1, x2, y2, r2):
    """Check collision between two circles"""
    dist = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
    return dist < (r1 + r2)

def check_ghost_collision(player, ghosts):
    """Check collisions between player and ghosts"""
    for ghost in ghosts:
        if circle_collision(player.x, player.y, player.radius,
                          ghost.x, ghost.y, ghost.radius):
            if ghost.state == "frightened":
                # Player eats ghost
                ghost.state = "eaten"
                ghost.reset_position()
                player.score += 200
            elif ghost.state != "eaten":
                # Ghost catches player
                return ghost
    return None
```

### Stage 2 Testing Checklist
- [ ] 4 ghosts spawn with different colors
- [ ] Each ghost has unique movement pattern
- [ ] Ghosts chase player appropriately
- [ ] Collision with ghost (not powered) loses life
- [ ] Collision with ghost (powered) eats ghost
- [ ] Eaten ghosts respawn in ghost house
- [ ] Frightened ghosts turn blue and slow down
- [ ] Ghost AI switches between scatter and chase
- [ ] Code committed to Git

### Git Commands for Stage 2
```bash
git add .
git commit -m "Stage 2: Ghost AI complete - 4 unique behaviors + collision"
```

---

## **STAGE 3: UI & GAME STATES** ğŸ¨

### Objectives
- Implement complete HUD (score, lives, level, combo)
- Add start menu and game over screens
- Implement pause functionality
- Add particle effects for pellet collection
- Display ghost AI state indicators
- Show achievement notifications

### Deliverables

#### 3.1 HUD System (src/ui/hud.py)
```python
"""Heads-up display"""
import pygame
from src.config import *

class HUD:
    def __init__(self, screen_width, screen_height):
        self.width = screen_width
        self.height = screen_height
        self.font_large = pygame.font.Font(None, 48)
        self.font_medium = pygame.font.Font(None, 36)
        self.font_small = pygame.font.Font(None, 24)
        
    def render(self, screen, player, level, combo=1):
        """Render all HUD elements"""
        # Score
        score_text = self.font_large.render(f"SCORE: {player.score}", True, WHITE)
        screen.blit(score_text, (20, 10))
        
        # Lives
        lives_text = self.font_medium.render(f"LIVES:", True, WHITE)
        screen.blit(lives_text, (20, 60))
        for i in range(player.lives):
            pygame.draw.circle(screen, NEON_YELLOW, (120 + i * 30, 75), 10)
            
        # Level
        level_text = self.font_medium.render(f"LEVEL: {level}", True, NEON_BLUE)
        screen.blit(level_text, (self.width - 200, 10))
        
        # Combo multiplier
        if combo > 1:
            combo_text = self.font_large.render(f"x{combo} COMBO!", True, NEON_GREEN)
            text_rect = combo_text.get_rect(center=(self.width // 2, 50))
            screen.blit(combo_text, text_rect)
            
        # Power-up timer
        if player.powered_up:
            timer_width = 200
            timer_height = 20
            timer_x = (self.width - timer_width) // 2
            timer_y = self.height - 40
            
            # Background
            pygame.draw.rect(screen, GRAY, (timer_x, timer_y, timer_width, timer_height))
            
            # Fill based on remaining time
            fill_width = int((player.power_timer / POWER_PELLET_DURATION) * timer_width)
            pygame.draw.rect(screen, NEON_YELLOW, (timer_x, timer_y, fill_width, timer_height))
            
            # Border
            pygame.draw.rect(screen, WHITE, (timer_x, timer_y, timer_width, timer_height), 2)
```

#### 3.2 Menu System (src/ui/menus.py)
```python
"""Menu screens"""
import pygame
from src.config import *

class MenuManager:
    def __init__(self, screen_width, screen_height):
        self.width = screen_width
        self.height = screen_height
        self.font_title = pygame.font.Font(None, 72)
        self.font_large = pygame.font.Font(None, 48)
        self.font_medium = pygame.font.Font(None, 36)
        
    def render_start_menu(self, screen):
        """Render start menu"""
        screen.fill(BLACK)
        
        # Title
        title = self.font_title.render("PAC-MAN", True, NEON_YELLOW)
        title_rect = title.get_rect(center=(self.width // 2, 200))
        screen.blit(title, title_rect)
        
        # Subtitle
        subtitle = self.font_medium.render("Retro Futuristic Edition", True, NEON_BLUE)
        subtitle_rect = subtitle.get_rect(center=(self.width // 2, 280))
        screen.blit(subtitle, subtitle_rect)
        
        # Instructions
        play_text = self.font_large.render("Press SPACE to Start", True, WHITE)
        play_rect = play_text.get_rect(center=(self.width // 2, 400))
        screen.blit(play_text, play_rect)
        
        controls = [
            "WASD or Arrow Keys - Move",
            "P - Pause",
            "ESC - Quit"
        ]
        
        y_offset = 500
        for control in controls:
            text = self.font_medium.render(control, True, GRAY)
            text_rect = text.get_rect(center=(self.width // 2, y_offset))
            screen.blit(text, text_rect)
            y_offset += 40
            
    def render_pause_menu(self, screen):
        """Render pause overlay"""
        # Semi-transparent overlay
        overlay = pygame.Surface((self.width, self.height))
        overlay.set_alpha(128)
        overlay.fill(BLACK)
        screen.blit(overlay, (0, 0))
        
        # Pause text
        pause_text = self.font_title.render("PAUSED", True, NEON_YELLOW)
        pause_rect = pause_text.get_rect(center=(self.width // 2, self.height // 2))
        screen.blit(pause_text, pause_rect)
        
        # Resume instruction
        resume_text = self.font_medium.render("Press P to Resume", True, WHITE)
        resume_rect = resume_text.get_rect(center=(self.width // 2, self.height // 2 + 60))
        screen.blit(resume_text, resume_rect)
        
    def render_game_over(self, screen, score, level):
        """Render game over screen"""
        screen.fill(BLACK)
        
        # Game Over text
        game_over = self.font_title.render("GAME OVER", True, NEON_PINK)
        game_over_rect = game_over.get_rect(center=(self.width // 2, 200))
        screen.blit(game_over, game_over_rect)
        
        # Final score
        score_text = self.font_large.render(f"Final Score: {score}", True, WHITE)
        score_rect = score_text.get_rect(center=(self.width // 2, 320))
        screen.blit(score_text, score_rect)
        
        # Level reached
        level_text = self.font_medium.render(f"Level Reached: {level}", True, NEON_BLUE)
        level_rect = level_text.get_rect(center=(self.width // 2, 380))
        screen.blit(level_text, level_rect)
        
        # Restart instruction
        restart_text = self.font_medium.render("Press SPACE to Restart", True, WHITE)
        restart_rect = restart_text.get_rect(center=(self.width // 2, 500))
        screen.blit(restart_text, restart_rect)
```

#### 3.3 Particle Effects (src/ui/particles.py)
```python
"""Particle system for visual effects"""
import pygame
import random
from src.config import *

class Particle:
    def __init__(self, x, y, color):
        self.x = x
        self.y = y
        self.vx = random.uniform(-2, 2)
        self.vy = random.uniform(-2, 2)
        self.color = color
        self.life = 30  # frames
        self.size = random.randint(2, 4)
        
    def update(self):
        """Update particle position"""
        self.x += self.vx
        self.y += self.vy
        self.life -= 1
        self.size = max(1, self.size - 0.1)
        
    def is_dead(self):
        """Check if particle should be removed"""
        return self.life <= 0
        
    def render(self, screen):
        """Render particle"""
        alpha = int(255 * (self.life / 30))
        color = (*self.color, alpha)
        pygame.draw.circle(screen, self.color, (int(self.x), int(self.y)), int(self.size))

class ParticleSystem:
    def __init__(self):
        self.particles = []
        
    def emit(self, x, y, color, count=5):
        """Emit particles"""
        for _ in range(count):
            self.particles.append(Particle(x, y, color))
            
    def update(self):
        """Update all particles"""
        for particle in self.particles[:]:
            particle.update()
            if particle.is_dead():
                self.particles.remove(particle)
                
    def render(self, screen):
        """Render all particles"""
        for particle in self.particles:
            particle.render(screen)
```

### Stage 3 Testing Checklist
- [ ] Start menu displays correctly
- [ ] HUD shows score, lives, level
- [ ] Power-up timer bar works
- [ ] Combo multiplier displays
- [ ] Pause menu works (P key)
- [ ] Game over screen shows final stats
- [ ] Particle effects appear on pellet collection
- [ ] Ghost state indicators visible
- [ ] All UI elements are readable
- [ ] Code committed to Git

### Git Commands for Stage 3
```bash
git add .
git commit -m "Stage 3: UI complete - HUD, menus, particles"
```

---

## **STAGE 4: PROGRESSIVE LEVELS & POWER-UPS** ğŸ¯

### Objectives
- Implement 4 distinct level types with unique mechanics
- Add player power-ups (Speed, Shield, Freeze)
- Implement level progression system
- Add keys, portals, and ghost powers
- Increase difficulty progressively

### Level Progression
1. **Level 1: Classic** - Basic pellet collection
2. **Level 2: Key Hunt** - Collect keys to unlock areas
3. **Level 3: Ghost Powers** - Ghosts have special abilities
4. **Level 4: Portal Maze** - Teleportation portals

### Deliverables

#### 4.1 Level Manager (src/levels/level_manager.py)
```python
"""Level progression and management"""
from src.config import *
from src.levels.maze import Maze

class Level:
    def __init__(self, number, level_type, difficulty_multiplier):
        self.number = number
        self.type = level_type  # "classic", "keys", "powers", "portals"
        self.difficulty = difficulty_multiplier
        self.maze = Maze()
        self.keys_collected = 0
        self.keys_required = 0
        self.portals = []
        self.locked_areas = []
        
    def setup_level_mechanics(self):
        """Setup level-specific mechanics"""
        if self.type == "keys":
            self.keys_required = 3
            self.spawn_keys()
        elif self.type == "portals":
            self.spawn_portals()

class LevelManager:
    def __init__(self):
        self.current_level = 1
        self.levels = self.create_levels()
        
    def create_levels(self):
        """Create all level configurations"""
        return [
            Level(1, "classic", 1.0),
            Level(2, "keys", 1.2),
            Level(3, "powers", 1.5),
            Level(4, "portals", 1.8),
        ]
        
    def get_current_level(self):
        """Get current level"""
        idx = min(self.current_level - 1, len(self.levels) - 1)
        return self.levels[idx]
        
    def next_level(self):
        """Advance to next level"""
        self.current_level += 1
        level = self.get_current_level()
        level.setup_level_mechanics()
        return level
        
    def adjust_ghost_difficulty(self, ghosts):
        """Adjust ghost behavior for current level"""
        level = self.get_current_level()
        for ghost in ghosts:
            ghost.speed = GHOST_SPEED * level.difficulty
```

#### 4.2 Power-up System (src/entities/powerup.py)
```python
"""Player power-up items"""
import pygame
import random
from src.config import *

class PowerUp:
    def __init__(self, x, y, powerup_type):
        self.x = x
        self.y = y
        self.type = powerup_type  # "speed", "shield", "freeze"
        self.duration = 5000  # milliseconds
        self.collected = False
        self.spawn_time = pygame.time.get_ticks()
        self.lifetime = 10000  # disappears after 10 seconds
        
    def check_collision(self, player):
        """Check if player collected power-up"""
        dist = ((self.x - player.x)**2 + (self.y - player.y)**2)**0.5
        return dist < (player.radius + 10)
        
    def apply_effect(self, player):
        """Apply power-up effect to player"""
        if self.type == "speed":
            player.speed *= 1.5
            player.powerup_type = "speed"
        elif self.type == "shield":
            player.has_shield = True
            player.powerup_type = "shield"
        elif self.type == "freeze":
            player.freeze_active = True
            player.powerup_type = "freeze"
            
        player.powerup_timer = self.duration
        self.collected = True
        
    def is_expired(self):
        """Check if power-up has expired"""
        return pygame.time.get_ticks() - self.spawn_time > self.lifetime
        
    def render(self, screen, offset_x=0, offset_y=0):
        """Render power-up"""
        if self.collected:
            return
            
        px = offset_x + int(self.x)
        py = offset_y + int(self.y)
        
        # Choose color based on type
        if self.type == "speed":
            color = NEON_GREEN
            symbol = "S"
        elif self.type == "shield":
            color = NEON_BLUE
            symbol = "â—†"
        elif self.type == "freeze":
            color = NEON_PURPLE
            symbol = "â„"
            
        # Draw power-up
        pygame.draw.circle(screen, color, (px, py), 12)
        pygame.draw.circle(screen, WHITE, (px, py), 12, 2)
        
        # Draw symbol
        font = pygame.font.Font(None, 24)
        text = font.render(symbol, True, BLACK)
        text_rect = text.get_rect(center=(px, py))
        screen.blit(text, text_rect)

class PowerUpManager:
    def __init__(self):
        self.powerups = []
        self.spawn_timer = 0
        self.spawn_interval = 15000  # Spawn every 15 seconds
        
    def update(self, dt, maze, player, ghosts):
        """Update power-up system"""
        self.spawn_timer += dt * 1000
        
        # Spawn new power-up
        if self.spawn_timer >= self.spawn_interval:
            self.spawn_random_powerup(maze)
            self.spawn_timer = 0
            
        # Update existing power-ups
        for powerup in self.powerups[:]:
            if powerup.is_expired():
                self.powerups.remove(powerup)
            elif powerup.check_collision(player):
                powerup.apply_effect(player)
                self.powerups.remove(powerup)
                
        # Update player power-up effects
        if hasattr(player, 'powerup_timer') and player.powerup_timer > 0:
            player.powerup_timer -= dt * 1000
            
            if player.powerup_timer <= 0:
                self.remove_powerup_effect(player)
                
        # Apply freeze effect to ghosts
        if hasattr(player, 'freeze_active') and player.freeze_active:
            for ghost in ghosts:
                if ghost.state not in ["eaten", "frightened"]:
                    ghost.speed = GHOST_SPEED * 0.3  # 70% slower
                    
    def spawn_random_powerup(self, maze):
        """Spawn a random power-up in valid location"""
        powerup_types = ["speed", "shield", "freeze"]
        powerup_type = random.choice(powerup_types)
        
        # Find valid spawn location
        while True:
            x = random.randint(2, MAZE_WIDTH - 2) * TILE_SIZE
            y = random.randint(2, MAZE_HEIGHT - 2) * TILE_SIZE
            
            grid_x = int(x / TILE_SIZE)
            grid_y = int(y / TILE_SIZE)
            
            if maze.is_walkable(grid_x, grid_y):
                self.powerups.append(PowerUp(x, y, powerup_type))
                break
                
    def remove_powerup_effect(self, player):
        """Remove power-up effect from player"""
        if hasattr(player, 'powerup_type'):
            if player.powerup_type == "speed":
                player.speed = PLAYER_SPEED
            elif player.powerup_type == "shield":
                player.has_shield = False
            elif player.powerup_type == "freeze":
                player.freeze_active = False
                
            player.powerup_type = None
            
    def render(self, screen, offset_x=0, offset_y=0):
        """Render all power-ups"""
        for powerup in self.powerups:
            powerup.render(screen, offset_x, offset_y)
```

### Stage 4 Testing Checklist
- [ ] Level progression works correctly
- [ ] Level 1 (Classic) plays normally
- [ ] Level 2 (Keys) spawns keys and locked areas
- [ ] Level 3 (Powers) ghosts have enhanced abilities
- [ ] Level 4 (Portals) teleportation works
- [ ] Speed power-up increases player speed
- [ ] Shield power-up prevents one death
- [ ] Freeze power-up slows ghosts
- [ ] Power-ups spawn periodically
- [ ] Difficulty increases per level
- [ ] Code committed to Git

### Git Commands for Stage 4
```bash
git add .
git commit -m "Stage 4: Progressive levels + power-ups complete"
```

---

## **STAGE 5: POLISH & WEB DEPLOYMENT** ğŸš€

### Objectives
- Add sound effects (optional)
- Implement achievement system
- Add smooth transitions and animations
- Optimize performance
- Configure for web deployment with Pygbag
- Create comprehensive README

### Deliverables

#### 5.1 Achievement System
```python
"""Achievement tracking"""

ACHIEVEMENTS = {
    "first_blood": {"name": "First Blood", "description": "Eat your first ghost", "icon": "ğŸ‘»"},
    "speed_demon": {"name": "Speed Demon", "description": "Complete a level in under 2 minutes", "icon": "âš¡"},
    "untouchable": {"name": "Untouchable", "description": "Complete a level without losing a life", "icon": "ğŸ›¡ï¸"},
    "key_master": {"name": "Key Master", "description": "Collect all keys in Level 2", "icon": "ğŸ”‘"},
    "combo_king": {"name": "Combo King", "description": "Achieve a 5x combo", "icon": "ğŸ”¥"},
    "level_4_complete": {"name": "Portal Master", "description": "Complete Level 4", "icon": "ğŸŒ€"},
}

class AchievementManager:
    def __init__(self):
        self.unlocked = set()
        self.notifications = []
        
    def unlock(self, achievement_id):
        """Unlock an achievement"""
        if achievement_id not in self.unlocked and achievement_id in ACHIEVEMENTS:
            self.unlocked.add(achievement_id)
            self.notifications.append({
                "achievement": ACHIEVEMENTS[achievement_id],
                "time": pygame.time.get_ticks(),
                "duration": 3000
            })
            
    def update(self):
        """Update notifications"""
        current_time = pygame.time.get_ticks()
        self.notifications = [n for n in self.notifications 
                            if current_time - n["time"] < n["duration"]]
                            
    def render(self, screen):
        """Render achievement notifications"""
        y_offset = 100
        for notification in self.notifications:
            achievement = notification["achievement"]
            
            # Background
            pygame.draw.rect(screen, (0, 0, 0, 200), (20, y_offset, 300, 60))
            pygame.draw.rect(screen, NEON_YELLOW, (20, y_offset, 300, 60), 2)
            
            # Icon and text
            font = pygame.font.Font(None, 36)
            icon_text = font.render(achievement["icon"], True, WHITE)
            screen.blit(icon_text, (30, y_offset + 10))
            
            name_text = font.render(achievement["name"], True, NEON_YELLOW)
            screen.blit(name_text, (70, y_offset + 10))
            
            desc_font = pygame.font.Font(None, 20)
            desc_text = desc_font.render(achievement["description"], True, WHITE)
            screen.blit(desc_text, (70, y_offset + 35))
            
            y_offset += 70
```

#### 5.2 Web Deployment Configuration

Create `build_web.sh`:
```bash
#!/bin/bash

echo "Building Pac-Man for Web..."

# Create build directory
mkdir -p build

# Copy necessary files
cp main.py build/
cp -r src build/
cp -r assets build/ 2>/dev/null || :

# Build with Pygbag
python -m pygbag --build build/

echo "Build complete! Check the build/ directory"
echo "To test locally: python -m http.server 8000"
```

#### 5.3 Comprehensive README
```markdown
# ğŸ® PAC-MAN: Retro Futuristic Edition

A modern recreation of the classic Pac-Man game with progressive levels, adaptive AI, and power-ups.

## ğŸ¯ Features

### Core Gameplay
- âœ… Classic Pac-Man mechanics with modern enhancements
- âœ… 4 ghosts with unique AI behaviors
- âœ… Smooth movement and collision detection
- âœ… Power pellets with frightened mode

### Progressive Levels
1. **Level 1: Classic** - Traditional pellet collection
2. **Level 2: Key Hunt** - Collect keys to unlock areas
3. **Level 3: Ghost Powers** - Enhanced ghost abilities
4. **Level 4: Portal Maze** - Teleportation mechanics

### Power-Ups
- âš¡ **Speed Boost** - Move faster temporarily
- ğŸ›¡ï¸ **Shield** - Protect against one ghost collision
- â„ï¸ **Freeze** - Slow down all ghosts

### UI Features
- Real-time score tracking
- Lives display
- Level indicator
- Combo multiplier
- Power-up timer
- Achievement notifications
- Ghost AI state indicators

## ğŸ› ï¸ Installation

### Local Play
```bash
# Clone repository
git clone <repository-url>
cd pacman-game

# Install dependencies
pip install -r requirements.txt --break-system-packages

# Run game
python main.py
```

### Web Version
```bash
# Build for web
chmod +x build_web.sh
./build_web.sh

# Serve locally
cd build
python -m http.server 8000

# Open browser to http://localhost:8000
```

## ğŸ® Controls

- **Arrow Keys** or **WASD** - Move Pac-Man
- **P** - Pause game
- **ESC** - Quit to menu
- **SPACE** - Start game / Restart

## ğŸ† Achievements

- ğŸ‘» **First Blood** - Eat your first ghost
- âš¡ **Speed Demon** - Complete level in under 2 minutes
- ğŸ›¡ï¸ **Untouchable** - Complete level without losing a life
- ğŸ”‘ **Key Master** - Collect all keys in Level 2
- ğŸ”¥ **Combo King** - Achieve a 5x combo
- ğŸŒ€ **Portal Master** - Complete Level 4

## ğŸ¤– Ghost AI

### Blinky (Red)
- **Behavior**: Aggressive direct chaser
- **Target**: Player's current position

### Pinky (Pink)
- **Behavior**: Ambush predator
- **Target**: 4 tiles ahead of player

### Inky (Cyan)
- **Behavior**: Strategic flanker
- **Target**: Complex calculation based on player and Blinky

### Clyde (Orange)
- **Behavior**: Shy/Random
- **Target**: Player when far, scatter when close

## ğŸ“Š Technical Details

- **Engine**: Pygame 2.5+
- **Language**: Python 3.10+
- **Target FPS**: 60
- **Resolution**: 800x900
- **Web Framework**: Pygbag

## ğŸ¨ Visual Style

Retro-futuristic design with:
- Neon color palette
- Minimalist modern UI
- Particle effects
- Smooth animations
- Glow effects

## ğŸ“ Development

Built in 5 progressive stages:
1. Foundation & core mechanics
2. Ghost AI & collision
3. UI & game states
4. Progressive levels & power-ups
5. Polish & deployment

## ğŸ“œ License

This is a educational recreation of Pac-Man. Original game Â© Namco.

## ğŸ™ Credits

- Original Pac-Man by Toru Iwatani (Namco, 1980)
- Recreation by [Your Name]
- Built with Pygame and Python
```

### Stage 5 Testing Checklist
- [ ] All achievements unlock correctly
- [ ] Smooth transitions between screens
- [ ] Performance is stable (60 FPS)
- [ ] Web build works in browser
- [ ] All features functional
- [ ] README complete and accurate
- [ ] No critical bugs
- [ ] Code fully documented
- [ ] Final commit to Git

### Git Commands for Stage 5
```bash
git add .
git commit -m "Stage 5: Polish complete - ready for deployment"
git tag v1.0.0
```

---

## ğŸ¯ CORE GAME MECHANICS

### Movement System
- Grid-based movement with smooth interpolation
- 4-directional controls (up, down, left, right)
- Movement queuing for responsive controls
- Wall collision with tile-perfect detection
- Screen wrapping at tunnel edges

### Scoring System
```python
SCORING = {
    "pellet": 10,
    "power_pellet": 50,
    "ghost_1": 200,
    "ghost_2": 400,
    "ghost_3": 800,
    "ghost_4": 1600,
    "fruit": 500,
    "key": 100,
    "level_complete": 1000,
}
```

### Combo System
- Eating multiple ghosts in powered-up state increases multiplier
- Combo resets when power-up expires
- Bonus points for maintaining combos

### Lives System
- Start with 3 lives
- Lose life on ghost collision (when not powered up)
- Shield power-up prevents one death
- Game over when lives reach 0

---

## ğŸ¨ VISUAL DESIGN GUIDELINES

### Color Palette
```python
# Primary neon colors
NEON_YELLOW = (255, 255, 0)    # Pac-Man
NEON_PINK = (255, 20, 147)     # Blinky
NEON_BLUE = (0, 240, 255)      # Inky, UI elements
NEON_ORANGE = (255, 140, 0)    # Clyde
NEON_GREEN = (57, 255, 20)     # Power-ups, Pinky
NEON_PURPLE = (191, 64, 191)   # Special effects

# Background
BLACK = (10, 10, 15)           # Slightly blue-tinted black
```

### Animation Guidelines
- Smooth 60 FPS animations
- Easing functions for transitions
- Particle effects on important events
- Glow effects on active power-ups
- Flash effects for invincibility

### UI Design Principles
- Minimalist but informative
- High contrast for readability
- Consistent neon aesthetic
- Clear visual hierarchy
- Responsive feedback

---

## ğŸ§ª TESTING & VALIDATION

### Performance Targets
- **FPS**: Maintain 60 FPS consistently
- **Load Time**: < 2 seconds to game start
- **Memory**: < 100 MB RAM usage
- **Responsive**: Input lag < 16ms

### Test Scenarios

#### Stage 1 Tests
1. Launch game window
2. Move in all four directions
3. Collect 10 pellets
4. Collect 1 power pellet
5. Verify score increases
6. Test wall collision
7. Verify maze renders correctly

#### Stage 2 Tests
1. Spawn all 4 ghosts
2. Verify unique movement patterns
3. Collide with ghost (not powered)
4. Verify life lost
5. Collide with ghost (powered)
6. Verify ghost eaten
7. Test ghost respawn
8. Verify frightened mode timing

#### Stage 3 Tests
1. Verify HUD displays all elements
2. Test pause functionality
3. Complete level to see level complete screen
4. Lose all lives to see game over screen
5. Verify particle effects appear
6. Test all menu navigation

#### Stage 4 Tests
1. Complete level 1
2. Verify progression to level 2
3. Test key collection in level 2
4. Test ghost powers in level 3
5. Test portal teleportation in level 4
6. Collect each power-up type
7. Verify power-up effects
8. Test difficulty scaling

#### Stage 5 Tests
1. Unlock all achievements
2. Verify achievement notifications
3. Test web build in browser
4. Verify mobile controls (if implemented)
5. Performance test all levels
6. Final playthrough without bugs

---

## ğŸ“¦ GIT WORKFLOW

### Initial Setup
```bash
# Initialize repository
git init

# Create .gitignore
cat > .gitignore << EOF
__pycache__/
*.pyc
*.pyo
build/
dist/
*.egg-info/
.vscode/
.DS_Store
EOF

# Initial commit
git add .
git commit -m "Initial commit: Project structure"
```

### Stage Commits
Each stage should have a descriptive commit:

```bash
# After Stage 1
git add .
git commit -m "Stage 1: Foundation - Basic gameplay and maze rendering"

# After Stage 2
git add .
git commit -m "Stage 2: AI Implementation - 4 unique ghost behaviors"

# After Stage 3
git add .
git commit -m "Stage 3: UI System - Complete HUD and menus"

# After Stage 4
git add .
git commit -m "Stage 4: Progression - 4 levels with unique mechanics"

# After Stage 5
git add .
git commit -m "Stage 5: Polish - Achievements and web deployment"
git tag v1.0.0
```

### Branch Strategy (Optional)
```bash
# Create feature branches for major features
git checkout -b feature/ghost-ai
# ... work on feature ...
git checkout main
git merge feature/ghost-ai

# Create branch for experimental features
git checkout -b experiment/procedural-levels
```

---

## ğŸš€ DEPLOYMENT INSTRUCTIONS

### Web Deployment with Pygbag

#### Prerequisites
```bash
pip install pygbag --break-system-packages
```

#### Build Process
```bash
# Create build directory
mkdir -p build

# Copy game files
cp main.py build/
cp -r src build/
cp -r assets build/  # If you have assets

# Build for web
cd build
python -m pygbag --build .

# This creates an HTML/WASM bundle
```

#### Testing Locally
```bash
# Serve the build directory
python -m http.server 8000

# Open browser to:
# http://localhost:8000
```

#### Hosting Options
1. **GitHub Pages**: Push build/ directory to gh-pages branch
2. **Itch.io**: Upload build folder as HTML5 game
3. **Netlify**: Deploy build directory
4. **Vercel**: Deploy as static site

### Desktop Deployment (Optional)

#### Using PyInstaller
```bash
pip install pyinstaller --break-system-packages

# Create executable
pyinstaller --onefile --windowed main.py

# Executable will be in dist/ directory
```

---

## ğŸ¯ CLAUDE CODE DIRECTIVES

### Autonomous Operation Mode
```yaml
PERMISSIONS:
  directory_access: FULL
  file_creation: UNRESTRICTED
  file_modification: UNRESTRICTED
  git_operations: FULL
  network_access: REQUIRED_FOR_PACKAGES

APPROVAL_REQUIRED: FALSE

OPERATION_MODE: AUTONOMOUS
```

### Development Workflow
1. **Read this document thoroughly**
2. **Create project structure**
3. **Initialize Git repository**
4. **Execute Stage 1 completely**
5. **Test Stage 1 thoroughly**
6. **Commit Stage 1**
7. **Proceed to Stage 2**
8. **Repeat for all stages**
9. **Final testing and optimization**
10. **Deploy to web**

### Error Handling
- If a stage fails testing, debug before proceeding
- Document any deviations from the plan
- If stuck, analyze the issue and find solution independently
- Use Python's debugging tools as needed

### Code Quality Standards
- Follow PEP 8 style guidelines
- Use type hints where appropriate
- Add docstrings to all classes and functions
- Keep functions focused and modular
- Comment complex algorithms
- Use meaningful variable names

### Performance Optimization
- Profile code to find bottlenecks
- Optimize render loops
- Use sprite groups for efficient rendering
- Cache frequently used calculations
- Minimize object creation in game loop

---

## ğŸ“‹ FINAL CHECKLIST

### Pre-Development
- [ ] Read entire instruction document
- [ ] Understand all 5 stages
- [ ] Set up development environment
- [ ] Install all required packages

### Stage 1 - Foundation
- [ ] Project structure created
- [ ] Git initialized
- [ ] Basic game loop working
- [ ] Maze rendering functional
- [ ] Player movement implemented
- [ ] Pellet collection working
- [ ] All tests passing
- [ ] Committed to Git

### Stage 2 - Ghost AI
- [ ] 4 ghost types implemented
- [ ] Unique AI behaviors working
- [ ] Collision detection functional
- [ ] Frightened mode working
- [ ] Ghost respawn working
- [ ] All tests passing
- [ ] Committed to Git

### Stage 3 - UI
- [ ] HUD implemented
- [ ] All menus working
- [ ] Particle effects added
- [ ] Pause functionality working
- [ ] Game states managed correctly
- [ ] All tests passing
- [ ] Committed to Git

### Stage 4 - Levels
- [ ] Level manager implemented
- [ ] 4 level types created
- [ ] Power-ups working
- [ ] Level progression working
- [ ] Difficulty scaling working
- [ ] All tests passing
- [ ] Committed to Git

### Stage 5 - Polish
- [ ] Achievements implemented
- [ ] Final optimizations done
- [ ] Web build created
- [ ] README completed
- [ ] All documentation updated
- [ ] Final tests passing
- [ ] Tagged release v1.0.0

### Deployment
- [ ] Web build tested in browser
- [ ] Game fully playable
- [ ] No critical bugs
- [ ] Performance acceptable
- [ ] README accurate
- [ ] Repository clean and organized

---

## ğŸ‰ SUCCESS CRITERIA

The project is considered complete when:

1. âœ… All 5 stages fully implemented
2. âœ… Game runs at 60 FPS consistently
3. âœ… All core features functional
4. âœ… 4 levels playable start to finish
5. âœ… All 4 ghost AI behaviors working
6. âœ… All 3 power-ups functional
7. âœ… Full UI/HUD implemented
8. âœ… Achievement system working
9. âœ… Web deployment successful
10. âœ… No critical bugs
11. âœ… Code fully documented
12. âœ… Git history complete
13. âœ… README comprehensive
14. âœ… Game is fun to play!

---

## ğŸ’¡ TIPS FOR CLAUDE CODE

### When Starting
- Take time to understand the full scope
- Plan your approach before coding
- Set up the structure correctly first
- Test early and often

### During Development
- Complete each stage fully before moving on
- Test thoroughly at each stage
- Commit frequently with good messages
- Keep code organized and clean
- Refactor as needed

### Problem Solving
- Read error messages carefully
- Use print statements for debugging
- Test individual components in isolation
- Refer back to this document often
- Don't rush - quality over speed

### Final Steps
- Do a complete playthrough
- Test edge cases
- Optimize performance
- Polish visual details
- Verify web build works
- Celebrate! ğŸ‰

---

## ğŸ“š ADDITIONAL RESOURCES

### Pygame Documentation
- Official Docs: https://www.pygame.org/docs/
- Sprite Guide: https://www.pygame.org/docs/tut/SpriteIntro.html
- Event Handling: https://www.pygame.org/docs/ref/event.html

### Pathfinding Resources
- A* Algorithm: https://en.wikipedia.org/wiki/A*_search_algorithm
- Python A* Implementation: https://www.redblobgames.com/pathfinding/a-star/

### Pygbag Documentation
- GitHub: https://github.com/pygame-web/pygbag
- Usage Guide: https://pygame-web.github.io/

---

## âš ï¸ IMPORTANT NOTES

1. **Incremental Development**: DO NOT skip stages. Each builds on the previous.

2. **Testing**: Test thoroughly at each stage. A bug in Stage 1 becomes harder to fix in Stage 5.

3. **Git Commits**: Commit frequently. Better to have too many commits than too few.

4. **Performance**: Monitor FPS throughout development. Optimize early if issues arise.

5. **Code Quality**: Write clean, readable code. Future you will thank present you.

6. **Documentation**: Comment your code as you write it. Don't leave it for later.

7. **Web Deployment**: Test the web build early and often. Don't wait until Stage 5.

8. **Have Fun**: You're building a game! Enjoy the process and be proud of your work.

---

## ğŸ® FINAL MESSAGE TO CLAUDE CODE

You have all the information needed to build a complete, polished Pac-Man game. This document is your roadmap. Follow it stage by stage, test thoroughly, commit frequently, and maintain high code quality standards.

You have full autonomy to make decisions, solve problems, and implement features as described. Trust the process, follow the stages, and create something amazing.

Remember: **Build in stages, test thoroughly, commit often, and have fun!**

**Now, let's build an amazing game! ğŸš€ğŸ‘¾ğŸ¯**

---

*Document Version: 1.0*
*Last Updated: 2025-11-01*
*Status: Ready for Implementation*